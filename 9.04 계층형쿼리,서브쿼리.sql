--------------------------------------------------------------------------------------
-- 계층형 쿼리 
-- START WITH : 계층의 첫 단계를 어디서 시작할 것인지의 대한 조건
               --루트(부모행)로 사용될 행을 지정
--------------------------------------------------------------------------------------
-- CONNECT BY PRIOR 자식 = 부모  -> 순방향 탐색
   --자식에 붙으면 순방향 => 자식에 자식을 찾아 가는 것
--------------------------------------------------------------------------------------
-- CONNECT BY 자식 = PRIOR 부모  -> 역방향 탐색
    -- 부모에 붙으면 역방향 => 부모를 찾아 찾아 가는 것 null까지 쭉쭉
--------------------------------------------------------------------------------------
-- ORDER SIBLINGS BY : 같은 레벨끼리의 정렬을 정함.
--------------------------------------------------------------------------------------
--CONNECT_BY_ISLEAF " 잎사귀인지 체크 잎사귀 lv4 true,false로 출력
--------------------------------------------------------------------------------------
SELECT 
    LEVEL AS LVL,
    LPAD(' ', 4*(LEVEL-1)) || emp_no || '(' || emp_nm || ')' AS "조직인원",
    A.dept_cd,
    B.dept_nm,
    A.emp_no,
    A.direct_manager_emp_no,
    CONNECT_BY_ISLEAF
FROM tb_emp A
JOIN tb_dept B
ON A.dept_cd = B.dept_cd
START WITH A.direct_manager_emp_no IS NULL
 --START WITH A.EMP_NO = '1000000037'
CONNECT BY PRIOR A.emp_no = A.direct_manager_emp_no
ORDER SIBLINGS BY A.emp_no DESC
;
--------------------------------------------------------------------------------------
SELECT
 emp_no,
 emp_nm,
 direct_manager_emp_no
 FROM
 TB_EMP;
--------------------------------------------------------------------------------------
--★ 컬럼값 리스트 봐서 중복 없으면 자식 , 중복 많으면 부모
------------------------------------------------------------------------------------------------
SELECT 
    LEVEL AS LVL,
    LPAD(' ', 4*(LEVEL-1)) || emp_no || '(' || emp_nm || ')' AS "조직인원",
    A.dept_cd,
    B.dept_nm,
    A.emp_no,
    A.direct_manager_emp_no,
    CONNECT_BY_ISLEAF
FROM tb_emp A
JOIN tb_dept B
ON A.dept_cd = B.dept_cd
--START WITH A.direct_manager_emp_no IS NULL
START WITH A.EMP_NO = '1000000037'
CONNECT BY   A.emp_no = PRIOR A.direct_manager_emp_no
ORDER SIBLINGS BY A.emp_no DESC
;
---------------------------------------------------------------------------------------------------
-- 서 브 쿼 리
---------------------------------------------------------------------------------------------------
--# 서브 쿼리 : SQL 안에 SQL이 포함된 구문
--## 단일행 서브쿼리 : 조회 결과가 1건 이하
---------------------------------------------------------------------------------------------------
--부서코드가 100004인 부서의 사원들 정보 조회
SELECT 
        emp_no,
        emp_nm,
        dept_cd
FROM tb_emp
WHERE dept_cd = '100004'
;
---------------------------------------------------------------------------------------------------
-- 이나라가 속한 부서의 모든 사원정보 조회
-- 1. 이나라는 부서코드가 몇번인가?
-- 2. 그 부서코드로 모든 사원 코드를 조회하라
---------------------------------------------------------------------------------------------------
SELECT 
        emp_no,
        emp_nm,
        dept_cd
FROM tb_emp
WHERE dept_cd = (
 SELECT
   dept_cd
 FROM tb_emp
 WHERE emp_nm ='이나라'
)
;
---------------------------------------------------------------------------------------------------
SELECT 
   dept_cd
    FROM tb_emp
    WHERE emp_nm='이관심'
    ;
    
--------------------------------------------------------------------------------------
SELECT 
        emp_no,
        emp_nm,
        dept_cd
FROM tb_emp
WHERE dept_cd IN (
 SELECT
   dept_cd
 FROM tb_emp
 WHERE emp_nm ='이관심'
)
;
---------------------------------------------------------------------------------------------------
-- 사원이름이 이관심인 사람이 속해 있는 부서의 사원정보 조회
-- 단일행 비교연산자(=, <>, >, >=, <, <=)는 단일행 서브쿼리로만 비교해야 함.
--------------------------------------------------------------------------------------
SELECT 
        emp_no,
        emp_nm,
        dept_cd
FROM tb_emp
WHERE dept_cd = (
 SELECT
   dept_cd
 FROM tb_emp
 WHERE emp_nm ='이나라'
)
;
---------------------------------------------------------------------------------------------------
-- 20200525에 받은 급여가 회사전체의 20200525일 
-- 전체 평균 급여보다 높은 사원들의 정보(사번, 이름, 급여지급일, 받은급여액수) 조회
---------------------------------------------------------------------------------------------------
--1.  회사 전체 20200525 평균 급여 계산
--2 그 평균 보다 높은 사람을 계산
SELECT 
e.emp_no,
e.emp_nm,
s.pay_de,
s.pay_amt
FROM TB_emp e
      join tb_Sal_his s
      on e.emp_no = s.emp_no
      where s.pay_de = '20200525'
      and s.pay_amt>=(
      select
        Round(avg(pay_amt),2)
      from tb_sal_his
      where pay_de = '20200525'
      )
      ;
--------------------------------------------------------------------------------------      
      select
        Round(avg(pay_amt),2)
      from tb_sal_his
      where pay_de = '20200525'
      ;
---------------------------------------------------------------------------------------------------
-- # 다중행 서브쿼리
-- 서브쿼리의 조회 건수가 0건 이상인 것
---------------------------------------------------------------------------------------------------
-- ## 다중행 연산자
-- 1. IN : 메인쿼리의 비교조건이 서브쿼리 결과중에 하나라도 일치하면 참
--    ex )  salary IN (200, 300, 400)
                     -- ㄴ =ANY   하나라도 맞으면 진행
--            250 ->  200, 300, 400 중에 없으므로 false

-- 2. ANY, SOME : 메인쿼리의 비교조건이 서브쿼리의 검색결과 중 하나 이상 일치하면 참
--    ex )  salary > ANY (200, 300, 400)
--                          ㄴ  이중에 하나보다 크면 true
--            250 ->  200보다 크므로 true
-- 3. ALL : 메인쿼리의 비교조건이 서브쿼리의 검색결과와 모두 일치하면 참
--    ex )  salary > ALL (200, 300, 400)
                          --ㄴ 모든 조건 만족해야함
--            250 ->  200보다는 크지만 300, 400보다는 크지 않으므로 false

-- 4. EXISTS : 메인쿼리의 비교조건이 서브쿼리의 결과 중 
--				만족하는 값이 하나라도 존재하면 참

--------------------------------------------------------------------------------------------------------
-- 한국데이터베이스진흥원에서 발급한 자격증을 가지고 있는
-- 사원의 사원번호와 사원이름과 해당 사원의 한국데이터베이스진흥원에서 
-- 발급한 자격증 개수를 조회
--------------------------------------------------------------------------------------------------------
SELECT
   E.EMP_NO,
   E.EMP_NM,
   COUNT(S.CERTI_CD) "자격증 개수"
FROM TB_EMP E 

INNER JOIN TB_EMP_CERTI S
ON E.EMP_NO = S.EMP_NO
WHERE S.CERTI_CD IN (  --in 대신 any 쓸 수 있음
SELECT certi_cd
from tb_certi
where tb_certi.issue_insti_nm='한국데이터베이스진흥원'
)
GROUP BY E.EMP_NO,E.EMP_NM
ORDER BY E.EMP_NO
;
--------------------------------------------------------------------------------------
-- EXISTS문 : 메인쿼리의 비교조건이 서브쿼리의 결과 중 
--           만족하는 값이 하나라도 존재하면 참
-- 주소가 강남인 직원들이 근무하고 있는 부서정보를 조회 (부서코드, 부서명)
--------------------------------------------------------------------------------------
SELECT 
DEPT_CD,
DEPT_NM
FROM TB_DEPT
WHERE DEPT_CD(100009,100010)
;
--------------------------------------------------------------------------------------
SELECT
    DEPT_CD,EMP_NM
FROM TB_EMP
WHERE ADDR LIKE '%강남%'
;
--------------------------------------------------------------------------------------
SELECT 
DEPT_CD,
DEPT_NM
FROM TB_DEPT D
WHERE  EXISTS (
SELECT
    DEPT_CD
FROM TB_EMP E
WHERE ADDR LIKE '%강남%'
    AND D.DEPT_CD = E.DEPT_cD
)
;
-------------------------------------------------------------------------------
SELECT * FROM TB_EMP_CERTI;

select 
distinct emp_nm  --중복 제거
from tb_emp;

select 
count(emp_nm || emp_no)  -- || 글자 붙이기
from tb_emp;

------------------------------------------------------------------------

-- # 다중 컬럼 서브쿼리
--  : 서브쿼리의 조회 컬럼이 2개 이상인 서브쿼리
------------------------------------------------------------------------
-- 부서원이 2명 이상인 부서 중에서 각 부서의 
-- 가장 연장자의 사번과 이름 생년월일과 부서코드를 조회
------------------------------------------------------------------------
SELECT 
    A.emp_no, A.emp_nm, A.birth_de, A.dept_cd, B.dept_nm
FROM tb_emp A
JOIN tb_dept B
ON A.dept_cd = B.dept_cd
WHERE (A.dept_cd, A.birth_de) IN (
                        SELECT 
                            dept_cd, MIN(birth_de)
                        FROM tb_emp
                        GROUP BY dept_cd
                        HAVING COUNT(*) >= 2
                    )
ORDER BY A.emp_no
;
---------------------------------------------------------------------
--인라인 뷰 서브쿼리 
--FROM 절에 쓰는 서브쿼리
---------------------------------------------------------------------
--각 사원의 사번과 이름과
-- 평균 급여정보를 알고 싶음
---------------------------------------------------------------------
--데이터가 아래꺼 너무 많음 
---------------------------------------------------------------------
SELECT 
E.EMP_NO,
E.EMP_NM,
ROUND(AVG(S.PAY_AMT),2)
FROM TB_EMP E
JOIN TB_SAL_HIS S
ON E.EMP_NO = S.EMP_NO
GROUP BY e.emp_no,e.emp_nm
ORDER BY E.EMP_NO
;

---------------------------------------------------------------------
--개선
---------------------------------------------------------------------
SELECT 
E.EMP_NO,
E.EMP_NM,
ROUND(AVG(S.PAY_AMT),2)
FROM TB_EMP E
JOIN (
SELECT EMP_NO, AVG(PAY_AMT) AS PAY_AVG
FROM TB_SAL_HIS
GROUP BY EMP_NO
)S
ON E.EMP_NO = S.EMP_NO
GROUP BY e.emp_no,e.emp_nm
ORDER BY E.EMP_NO
;
---------------------------------------------------------------------
-- 스칼라 서브쿼리 (SELECT, INSERT, UPDATE절에 쓰는 서브쿼리)

-- 사원의 사번, 사원명, 부서명, 생년월일, 성별코드를 조회
---------------------------------------------------------------------
-- 스칼라 서브쿼리 (SELECT, INSERT, UPDATE절에 쓰는 서브쿼리)  => 굳이 조인 할 필요 없을때 그냥 컬럼에 넣어서 테이블 데이터 읽어옴
SELECT 
    E.EMP_NO,
    E.EMP_NM,
    (SELECT DEPT_NM FROM TB_DEPT D WHERE E.DEPT_CD = D.DEPT_CD) AS DEPT_NM,                         --D.DEPT_NM
    E.BIRTH_DE,
    E.SEX_CD
FROM tb_emp E , TB_DEPT D
WHERE E.DEPT_CD = D.DEPT_CD
;
---------------------------------------------------------------------
